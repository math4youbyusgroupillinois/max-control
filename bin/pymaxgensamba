#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import os
import sys
from configobj import ConfigObj
import ldap
import commands
from pprint import pprint

CONF="/etc/max-control/conf.inc.php"
SMB_CONF="/etc/samba/smb.conf"
SHARED_DIR="/home/samba/groups/"

if not os.path.isfile(CONF):
    print " * No existe el archivo %s"%(CONF)
    sys.exit(0)

"""
[isos]
 comment = Archivos ISO
 path = /home/samba/shares/isos
 guest ok = yes
 #valid users =
 read list = @"__USERS__"
 write list = @"Teachers"
 admin users =
 read only = No
 browseable = No
 force create mode = 0664
 force directory mode = 0775
"""

TO_EDIT={
    'homes': {'hide files': '/desktop.ini/$RECYCLE.BIN/*.desktop/.*/', 'ea support':'yes', 'store dos attributes':'yes'},
    #'print$':{'browseable':'no'},
    'profiles': {'ea support':'yes', 'store dos attributes':'yes'},
    'global':{'server string': 'MAX server'},
}

TO_ADD={
        #'ebox-internal-backups':{'browseable':'no'},
        #'ebox-quarantine':{'browseable':'no'},qq
        #'global':{'full_audit:success':'none', 'full_audit:failure':'connect opendir open disconnect unlink mkdir rmdir rename'},
        'isos': {'comment': 'Archivos ISO', 
               'path': '/home/samba/shares/isos',
               #'valid users': ['@"Teachers"', '@"__USERS__"'],
               'read list': ['@"Teachers"', '@"__USERS__"'],
               #'write list': '@"Teachers"',
               'write list': ['@"Teachers"','@"Domain Admins"'],
               'read list': '@"__USERS__"',
               'admin users': '@"Domain Admins"',
               'guest ok': 'yes',
               'read only': 'no', 
               'browseable': 'no', 
               'force create mode': '0664', 
               'force directory mode': '0775',
               }
        }

NOT_VALID_KEYS=['global', 'netlogon', 'profiles', 'homes', 'ebox-internal-backups', 'ebox-quarantine', 'print$', 'isos']
HIDDEN_GROUPS=['Instaladores', 'CoordinadoresTIC']


def read_conf(varname):
    f=open(CONF, 'r')
    data=f.readlines()
    f.close()
    
    for line in data:
        if line.startswith('define') and varname in line:
            if len(line.split('"')) >= 3:
                return line.split('"')[3]
            if len(line.split("'")) >= 3:
                return line.split("'")[3]
    return ''

GROUPS=read_conf('LDAP_OU_GROUPS')
DOMAIN=read_conf('LDAP_DOMAIN')

def getGroupsShares():
    sharedgroups=[]
    l = ldap.initialize('ldap://localhost:389')
    l.simple_bind_s(read_conf("LDAP_BINDDN"), read_conf("LDAP_BINDPW"))
    results = l.search_s(GROUPS,ldap.SCOPE_SUBTREE,'(objectclass=posixGroup)', ['cn', 'member', 'gidNumber'])

    #import pprint
    #pprint.pprint(results)

    for group in results:
        if "Teachers" in group[0]:
            continue
        
        groupname=group[1]['cn'][0]
        
        if not groupname in HIDDEN_GROUPS:
            sharedgroups.append(groupname)
    return sharedgroups


class MyConfigObj (ConfigObj):
    def _write_line(self, indent_string, entry, this_entry, comment):
        """Write an individual line, for the write method"""
        # NOTE: the calls to self._quote here handles non-StringType values.
        if not self.unrepr:
            val = self._decode_element(self._quote(this_entry))
        else:
            val = repr(this_entry)
        
        # delete simple quote from groups names
        if "@" in val:
            val=val.replace("'", "")
        
        # add space before varname
        indent_string='    '
        
        return '%s%s%s%s%s' % (
            indent_string,
            self._decode_element(self._quote(entry, multiline=False)),
            self._a_to_u(' = '),
            val,
            self._decode_element(comment))


def newGroupShare(groupname, readonly):
    """
    [grupoprueba]
     comment = "grupoprueba share directory"
     path = /home/samba/groups/grupoprueba
     valid users = @"grupoprueba"
     force group = "grupoprueba"
     force create mode = 0660
     force directory mode = 0660
     printable = no
     read only = no
     browseable = yes
    # FIXME: Removed for samba 3.4.3, add again when a new version fixes it
    #% my $objects = 'full_audit';
     vfs objects =  recycle
     recycle: versions = yes
     recycle: repository = RecycleBin
     recycle: keeptree = yes
     recycle: excludedir = /tmp|/var/tmp
     recycle: directory_mode = 0700
    """
    #
    # readonly (for puppils) is read from st_mode
    #    * 17405 readonly false
    #    * 17401 readonly true
    #
    share={
            "comment": "compartido por %s"%groupname,
            "path": os.path.join(SHARED_DIR, groupname),
            #"valid users": '@"%s"'%groupname,
            "valid users": ['@"Domain Admins"', '@"%s"'%groupname],
            "force group": "%s"%groupname,
            "read list":  ['@"Domain Admins"', '@"%s"'%groupname],
            "write list": ['@"Domain Admins"', '@"%s"'%groupname],
            "admin users": '@"Domain Admins"',
            "force create mode":"0660",
            "force directory mode": "0770",
            "printable": "no",
            "read only": "no",
            "browseable": "yes",
          }
    if readonly == 1:
        print " * Group %s readonly for puppils."%groupname
        share["write list"]=['@"Domain Admins"', '@"Teachers"']
    return share



# def reloadSamba():
#     """
#       if testparm -s /etc/samba/smb.conf >/dev/null 2>&1; then
#         PIDS=$(pidof smbd)
#         for pid in $PIDS; do
#             kill -1 $pid
#         done
#         exit 0
#       else
#         exit 1
#       fi
#     """
#     testparm=commands.getstatusoutput('testparm -s /etc/samba/smb.conf >/dev/null 2>&1')
#     if testparm[0] != 0:
#         print "testparm error"
#         return False
#     PIDS=commands.getoutput('pidof smbd').split('\n')
#     for pid in PIDS:
#         commands.getstatusoutput("kill -1 %s"%pid)
#     return True

smb=MyConfigObj(SMB_CONF)
#
for key in TO_EDIT:
    for attr in TO_EDIT[key]:
        #print attr, "=" ,TO_EDIT[key][attr]
        smb[key][attr] = TO_EDIT[key][attr]
#
for key in TO_ADD:
    smb[key]=TO_ADD[key]
    if key in ['homes', 'profiles']:
        continue
    # FIXME isos owned by teachers
    result=commands.getstatusoutput("max-control createshared '%s' 'Teachers'"%key)
    #print "createshared ",key, " = " ,result
    if key not in NOT_VALID_KEYS:
        print " * Create shared", key

# delete not needed dir
os.system("rm -rf %s/homes" %SHARED_DIR)

ALL_GROUPS=getGroupsShares()
for group in ALL_GROUPS:
    if group in NOT_VALID_KEYS:
        # no create special sections
        continue
    
    # if exists check permisos
    groupdir=os.path.join(SHARED_DIR, group)
    if os.path.isdir(groupdir):
        #
        # readonly (for puppils) is read from st_mode
        #    * 17405 readonly false
        #    * 17401 readonly true
        #
        readonly=0
        if os.stat(groupdir).st_mode == 17401:
            readonly=1
        smb[group]=newGroupShare(group, readonly)
        result=commands.getstatusoutput("max-control addgroup '%s' '%s'"%(group, readonly))
        #print "addgroup ", group, " = " ,result
        print " * Add group", group


for group in HIDDEN_GROUPS:
    try:
        del(smb[group])
    except:
        pass

# import pprint
# pprint.pprint(smb)

smb.write()


# # test if smb.conf have include line
# f=open('/etc/samba/smb.conf', 'r')
# data=f.readlines()
# f.close()

# have_include=False
# for line in data:
#     if "include = /etc/samba/max-control.conf" in line:
#         have_include=True

# if not have_include:
#     f=open('/etc/samba/smb.conf', 'a')
#     f.write("\ninclude = /etc/samba/max-control.conf\n")
#     f.close()

if 'SUDO_USER' in os.environ and os.environ['SUDO_USER'] == 'ebox':
    sys.exit(0)

#print " * Restarting samba ..."
#commands.getstatusoutput("/etc/init.d/zentyal samba restart")
#reloadSamba()
